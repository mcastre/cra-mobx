'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var chalk = _interopDefault(require('chalk'));
var css = require('css');

function defaultClassNameReplacer(className, index) {
  return "emotion-" + index;
}

var componentSelectorClassNamePattern = /^e[a-zA-Z0-9]+[0-9]+$/;
var replaceClassNames = function replaceClassNames(classNames, styles, code, key, replacer) {
  if (replacer === void 0) {
    replacer = defaultClassNameReplacer;
  }

  var index = 0;
  return classNames.reduce(function (acc, className) {
    if (className.indexOf(key + "-") === 0 || componentSelectorClassNamePattern.test(className)) {
      var escapedRegex = new RegExp(className.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'), 'g');
      return acc.replace(escapedRegex, replacer(className, index++));
    }

    return acc;
  }, "" + styles + (styles ? '\n\n' : '') + code);
};

function getClassNames(selectors, classes) {
  return classes ? selectors.concat(classes.split(' ')) : selectors;
}

function getClassNamesFromTestRenderer(selectors, _ref) {
  var _ref$props = _ref.props,
      props = _ref$props === void 0 ? {} : _ref$props;
  return getClassNames(selectors, props.className || props.class);
}

function shouldDive(node) {
  return typeof node.dive === 'function' && typeof node.type() !== 'string';
}

function isTagWithClassName(node) {
  return node.prop('className') && typeof node.type() === 'string';
}

function getClassNamesFromEnzyme(selectors, node) {
  // We need to dive if we have selected a styled child from a shallow render
  var actualComponent = shouldDive(node) ? node.dive() : node; // Find the first node with a className prop

  var components = actualComponent.findWhere(isTagWithClassName);
  var classes = components.length && components.first().prop('className');
  return getClassNames(selectors, classes);
}

function getClassNamesFromCheerio(selectors, node) {
  var classes = node.attr('class');
  return getClassNames(selectors, classes);
}

function getClassNamesFromDOMElement(selectors, node) {
  return getClassNames(selectors, node.getAttribute('class'));
}

function isReactElement(val) {
  return val.$$typeof === Symbol.for('react.test.json');
}
var domElementPattern = /^((HTML|SVG)\w*)?Element$/;
function isDOMElement(val) {
  return val.nodeType === 1 && val.constructor && val.constructor.name && domElementPattern.test(val.constructor.name);
}

function isEnzymeElement(val) {
  return typeof val.findWhere === 'function';
}

function isCheerioElement(val) {
  return val.cheerio === '[cheerio object]';
}

function getClassNamesFromNodes(nodes) {
  return nodes.reduce(function (selectors, node) {
    if (isReactElement(node)) {
      return getClassNamesFromTestRenderer(selectors, node);
    } else if (isEnzymeElement(node)) {
      return getClassNamesFromEnzyme(selectors, node);
    } else if (isCheerioElement(node)) {
      return getClassNamesFromCheerio(selectors, node);
    }

    return getClassNamesFromDOMElement(selectors, node);
  }, []);
}

/*
 * Taken from
 * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L234
 */
function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === "[object " + typeName + "]";
}
/*
 * Taken from
 * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L36
 */


function isAsymmetric(obj) {
  return obj && isA('Function', obj.asymmetricMatch);
}

function valueMatches(declaration, value) {
  if (value instanceof RegExp) {
    return value.test(declaration.value);
  }

  if (isAsymmetric(value)) {
    return value.asymmetricMatch(declaration.value);
  }

  return value === declaration.value;
}

function getStylesFromClassNames(classNames, emotion) {
  return Object.keys(emotion.caches.registered).reduce(function (styles, className) {
    var indexOfClassName = classNames.indexOf(className);

    if (indexOfClassName !== -1) {
      var nameWithoutKey = classNames[indexOfClassName].substring(emotion.caches.key.length + 1); // $FlowFixMe

      styles += emotion.caches.inserted[nameWithoutKey];
    }

    return styles;
  }, '');
}

function createMatchers(emotion) {
  function toHaveStyleRule(received, property, value) {
    var selectors = getClassNamesFromNodes([received]);
    var cssString = getStylesFromClassNames(selectors, emotion);
    var styles = css.parse(cssString);
    var declaration = styles.stylesheet.rules.reduce(function (decs, rule) {
      return Object.assign([], decs, rule.declarations);
    }, []).filter(function (dec) {
      return dec.type === 'declaration' && dec.property === property;
    }).pop();

    if (!declaration) {
      return {
        pass: false,
        message: function message() {
          return "Property not found: " + property;
        }
      };
    }

    var pass = valueMatches(declaration, value);

    var message = function message() {
      return "Expected " + property + (pass ? ' not ' : ' ') + "to match:\n" + ("  " + chalk.green(value) + "\n") + 'Received:\n' + ("  " + chalk.red(declaration.value));
    };

    return {
      pass: pass,
      message: message
    };
  }

  return {
    toHaveStyleRule: toHaveStyleRule
  };
}

function getNodes(node, nodes) {
  if (nodes === void 0) {
    nodes = [];
  }

  if (node.children) {
    for (var _iterator = node.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var child = _ref;
      getNodes(child, nodes);
    }
  }

  if (typeof node === 'object') {
    nodes.push(node);
  }

  return nodes;
}

function getStyles(emotion) {
  return Object.keys(emotion.caches.inserted).reduce(function (style, current) {
    if (emotion.caches.inserted[current] === true) {
      return style;
    }

    return style + emotion.caches.inserted[current];
  }, '');
}
function createSerializer(emotion, _temp) {
  var _ref2 = _temp === void 0 ? {} : _temp,
      classNameReplacer = _ref2.classNameReplacer,
      _ref2$DOMElements = _ref2.DOMElements,
      DOMElements = _ref2$DOMElements === void 0 ? true : _ref2$DOMElements;

  function print(val, printer) {
    var nodes = getNodes(val);
    markNodes(nodes);
    var classNames = getClassNamesFromNodes(nodes);
    var styles = getStylesFromClassNames(classNames);
    var printedVal = printer(val);
    return replaceClassNames(classNames, styles, printedVal, emotion.caches.key, classNameReplacer);
  }

  function test(val) {
    return val && !val.withEmotionStyles && (DOMElements ? isReactElement(val) || isDOMElement(val) : isReactElement(val));
  }

  function markNodes(nodes) {
    nodes.forEach(function (node) {
      node.withEmotionStyles = true;
    });
  }

  function getStylesFromClassNames(classNames) {
    var styles = ''; // This could be done in a more efficient way
    // but it would be a breaking change to do so
    // because it would change the ordering of styles

    Object.keys(emotion.caches.registered).forEach(function (className) {
      var indexOfClassName = classNames.indexOf(className);

      if (indexOfClassName !== -1) {
        var nameWithoutKey = classNames[indexOfClassName].substring(emotion.caches.key.length + 1); // $FlowFixMe

        styles += emotion.caches.inserted[nameWithoutKey];
      }
    });
    var prettyStyles;

    try {
      prettyStyles = css.stringify(css.parse(styles));
    } catch (e) {
      console.error(e);
      throw new Error("There was an error parsing css in jest-emotion: \"" + styles + "\"");
    }

    return prettyStyles;
  }

  return {
    test: test,
    print: print
  };
}

exports.getStyles = getStyles;
exports.createSerializer = createSerializer;
exports.createMatchers = createMatchers;
